<!doctype html>
<!-- 
Name: Audrea Huang and Nanxi Liu
Assignment 6: Creative Scene
Date: April 15, 2022
Creates a static image of a nightmarket food stand.
-->
<html lang="en">
<head>
<meta charset="utf-8">
<title>Nightmarket</title>
<style>      
      canvas {
          display: block;
          margin: 10px auto;
          width: 800px;
          height: 500px;
      }
    </style>

<script src="https://cs.wellesley.edu/~cs307/threejs/libs/three-r95.all.js">
"https://cs.wellesley.edu/~cs307/threejs/libs/three-r80.min.js"
</script>
<script src="https://cs.wellesley.edu/~cs307/threejs/libs/OrbitControls-r95.js">
"https://cs.wellesley.edu/~cs307/threejs/libs/OrbitControls.js"
</script>
<script src="https://cs.wellesley.edu/~cs307/threejs/libs/tw-sp21.js">
"https://cs.wellesley.edu/~cs307/threejs/libs/tw-fa18.js"
</script>
<script src="https://cs.wellesley.edu/~cs307/threejs/libs/dat.gui-r95.js">
"https://cs.wellesley.edu/~cs307/threejs/libs/dat.gui.min.js"
</script>

</head>
<body>
<h1>Nightmarket</h1>
<p> <b>Name</b>: Nanxi Liu and Audrea Huang<br>
    <b>Assignment 6:</b> Creative Scene<br>
    <b>Date</b>: April 15, 2022<br>
    <b>Description</b>: The current state of the program creates a static scene of
    a candy stand at a nightmarket. To enrich the scene for the final project, we
    would like to add animation for Peppa making and selling the food as well as 
    customers coming to the booth and eating on stools. In order to avoid the stand
    feeling isolated, we will also add in the background flickering lights to 
    represent other nightmarket stands. The user can interact with the scene by 
    dragging the candies to move them and changing the colors of the stools and table
    with mouse clicks.
<br></p>

<script id="prog">
//````````````````````PARAMS HAS BEEN CHANGED BY NANXI``````````````````````````````
//the two dance arrays determine peppa's dance moves
var danceX = [2,1,-3,0,5,10,-5,6,6,0,1,-23];
var danceY = [1,2,3,4,0,5,-1,-2,-3,0,-4,-5];
var params = {
    poleRadius: 2,
    poleHeight: 50,
    tableWidth: 150,
    tableHeight: 20,
    tableDepth: 45,
    signHeight: 20,
    signDepth: 10,
    candyStickHeight: 8,
    //params for arms
    armRadius:0.5,
    armLength:12,
    armRotation:Math.PI/1.5,
    fingerLength:4,
    fingerRotation: Math.PI/6,
    fingerPosY: -3,
    //params for legs
    legRadius: 0.5,
    legHeight: 5,
    legRotation:0,
    footRadius: 0.5,
    footScaleX: 1,
    footScaleY: 0.5,
    footScaleZ: 2,
    footPositionZ: 1.5,
    footPositionY: -7.5,
    headRadius: 10,
    noseHeight:15,
    noseRadiusTop:4,
    noseRadiusBottom:8,
    noseRotationZ: 1,
    nosePositionX: -8,
    nosePositionY:7,
    bodyScaleY: 1.5,
    dimpleAngleX: Math.PI/2,
    dimpleAngleZ: -Math.PI/5,
    eyeRadius:1.5,
    eyeAngleXL: -Math.PI/4,
    eyeAngleYL: -Math.PI/10,
    eyeAngleXR: -Math.PI/6,
    eyeAngleYR: Math.PI/20,//Math.PI/10,
    eyeRotation:Math.PI*0.7,
    earRadius: 2,
    earScaleY: 2,
    earScaleZ:0.5,
    earAngle: -Math.PI/8,
    mouthRadius: 4,
    mouthAngleX: Math.PI/20,
    mouthRotationZ: Math.PI*0.99,
    mouthTube: 0.35,
    mouthRadialSegment: 10,
    mouthTubularSegment: 200,
    mouthArc: 2.4,
    armLength:10,
    fingerLength:3,
    legLength:8,
    footRadius:2,
    footStretchZ:1.5,
    //parameters FOR ANIMATION
    direction:1,
    rotationZ:0,
    dz:Math.PI/2,
    peppaPosX: 40,
    peppaPosY:-10,
    peppaPosZ:50,
    peppaRotation:0,
    /*@params parameters for peppa on the left*/
    peppa1X: -150,
    peppa1Y: 30,
    peppa1Z: 45,
    peppa1Color: 0x109de8,
    peppa1Rotation:Math.PI/4,
    /*@params parameters for peppa on the right*/
    peppa2X: 150,
    peppa2Y: 30,
    peppa2Z: 70,
    peppa2Color: 0xed9f2b,
    peppa2Rotation:-Math.PI/4,
    /*@params parameters for peppa in the middle*/
    peppa0X:0,
    peppa0Y: 30,
    peppa0Z: -45,
    peppa0Color: 0xf5574c,
    peppa0Rotation:0,
    peppaDressColor:0
}

//peppa is the global variable name for the object that's been clicked on
//the 3 dress variables are the global variable names for the figures' dresses, which the users can click on to make the figures dance.
var peppa, clock;
var dress1,dress2,dress3;

//```````````````````````````````````````````````````````````````````````````
//````````````````````````````````````````````````````````````````````````````
var textureGlobal; // textures for mapping images
var scene = new THREE.Scene(); 
scene.background = new THREE.Color( 0x15161A );
var renderer = new THREE.WebGLRenderer();
TW.mainInit(renderer,scene);

var table = new THREE.Object3D();

// create a box for the table
var tableGeom = new THREE.BoxGeometry(
                    params.tableWidth, params.tableHeight, params.tableDepth);
var tableMat = new THREE.MeshPhongMaterial({color: new THREE.Color("gray")});
var tableMesh = new THREE.Mesh(tableGeom, tableMat);

table.add(tableMesh);

// create the poles for the table
var pole = new THREE.CylinderGeometry( params.poleRadius,
                                        params.poleRadius,
                                        params.poleHeight );

var poleMat = new THREE.MeshPhongMaterial({color:new THREE.Color("grey")});
var poleMesh1 = new THREE.Mesh(pole,poleMat); // left
var poleMesh2 = new THREE.Mesh(pole,poleMat); // right

// set the position of the poles
poleMesh1.position.set( -params.tableWidth/2 + params.poleRadius,
                        params.poleHeight/2,
                        params.tableDepth/2 - params.poleRadius );

poleMesh2.position.set( params.tableWidth/2 - params.poleRadius,
                        params.poleHeight/2,
                        params.tableDepth/2-params.poleRadius );
table.add(poleMesh1);
table.add(poleMesh2);

function addTextureCoords (signGeom, textures) {
    /* add coordinates to map textures onto */
    if( ! signGeom instanceof THREE.Geometry ) {
        throw "not a THREE.Geometry: "+signGeom;
    }
    // array of face descriptors
    var UVs = [];
    function faceCoords(as,at, bs,bt, cs,ct) {
        UVs.push( [ new THREE.Vector2(as,at),
                    new THREE.Vector2(bs,bt),
                    new THREE.Vector2(cs,ct) ] );
    }
    // right (face 0-1)
    faceCoords(1,0, 0,0, 1,1);
    faceCoords(1,1, 0,0, 0,1);
    // left (faces 2-3)
    faceCoords(1,0, 0,1, 0,0);
    faceCoords(1,0, 1,1, 0,1);
    // top (faces 4-5)
    faceCoords(1,1, 1,0, 0,1);
    faceCoords(0,1, 1,1, 1,0);
    // bottom (faces 6-7)
    faceCoords(1,1, 1,1, 0,0);
    faceCoords(1,1, 0,1, 0,0);
    // front (faces 8-9)
    faceCoords(0,1, 0,0, 1,1);
    faceCoords(0,0, 1,0, 1,1);
    // back (faces 10-11)
    faceCoords(0,0, 1,0, 0,1);
    faceCoords(1,0, 1,1, 0,1);

    // attach this to the geometry
    signGeom.faceVertexUvs = [ UVs ];
}


function createSign(textures) {
    /* Create the sign for the nightmarket stand.
     * @param textures - list of textures */
    var signGeom = new THREE.BoxGeometry(
                    params.tableWidth, params.signHeight, params.signDepth);
    
    addTextureCoords(signGeom, textures);
    var materials = [ 
        new THREE.MeshPhongMaterial( {color: 0xffffff, map: textures[0]} ),
        new THREE.MeshPhongMaterial( {color: 0xffffff, map: textures[1]} ) ];
    
    // only map the sign name on the front
    for (var i=0; i<12; i++) {
        if (i == 8 || i == 9) {
            signGeom.faces[i].materialIndex = 0;
            signGeom.faces[i].materialIndex = 0;
        } else {
            signGeom.faces[i].materialIndex = 1;
        }
    }
    textures.needsUpdate = true;
    var signMesh = new THREE.Mesh(signGeom, materials);
    signMesh.position.set(0, params.poleHeight + params.signHeight/2, 
                        params.tableDepth/2 - params.signDepth / 4);

    table.add(signMesh);
}

// create an object for the stand as a whole so it is easier to move
// origin is at center of table
var marketStand = new THREE.Object3D();
marketStand.add(table);


// ===================
// food
// ===================

function createStick() {
    /* Creates the stick for the candy. */
    var stickGeom = new THREE.CylinderGeometry(
                        0.2, 0.2, params.candyStickHeight);
    var stickMat = new THREE.MeshPhongMaterial(
        {color:new THREE.Color(0x877d61)});
    var stickMesh = new THREE.Mesh(stickGeom, stickMat);
    return stickMesh;
}

function createBall() {
    /* Creates one of the red spherical candies. */
    var ballGeom = new THREE.SphereGeometry(1);
    var ballMat = new THREE.MeshPhongMaterial(
        {color:new THREE.Color("red"), side: THREE.DoubleSide});
    var ballMesh = new THREE.Mesh(ballGeom, ballMat);
    return ballMesh;
}

function createCandy() {
    /* Creates one instance of an entire candy, consisting of 
     * a stick and red candies.
     @return candy object */

    var candy = new THREE.Object3D();
    candy.add(createStick());
    ball1 = createBall();
    ball1.position.y = -params.candyStickHeight/2 + 5;
    candy.add(ball1);

    ball2 = createBall();
    ball2.position.y = -params.candyStickHeight/2 + 7;
    candy.add(ball2);

    ball2 = createBall();
    ball2.position.y = -params.candyStickHeight/2 + 9;
    candy.add(ball2);

    return candy;
}

// add candies to the stand
for (var j=0; j<10; j++) {
    // add candies on the left side of the table
    var candyL = createCandy();
    table.add(candyL);
    // increase position to the left
    candyL.position.set(
        j*-5 - params.tableDepth/3, params.tableHeight/2 + params.candyStickHeight/2, params.tableDepth/2);

    // add candies on the right
    var candyR = createCandy();
    table.add(candyR);
    candyR.position.set(
        j*5 + params.tableDepth/4, params.tableHeight/2 + params.candyStickHeight/2, params.tableDepth/2);

}


// ===================
// add peppa pig
// ====================
function makeHead(params,material) {
    /* Make a head for Peppa 
     * @param params - collection of dimensions to draw Peppa
     * @param material - color of head
     * @return THREE.Object3D for the head
     */
    var head = new THREE.Object3D();
    var headGeom = new THREE.SphereGeometry(params.headRadius,32,16);
    var headMesh = new THREE.Mesh(headGeom,material);
    head.add(headMesh);
    return head
}

function makeNose(params,material) {
    /* Makes, positions, and rotates a nose
     * @param params - collection of dimensions to draw Peppa
     * @param material - color of nose
     * @return THREE.Mesh for the nose
     */
    var noseGeom = new THREE.CylinderGeometry(
        params.noseRadiusTop,params.noseRadiusBottom,params.noseHeight);
    var noseMesh = new THREE.Mesh(noseGeom,material);
    noseMesh.position.set(params.nosePositionX,params.nosePositionY,0);
    noseMesh.rotation.z = params.noseRotationZ;
    return noseMesh
}

function createEye(params,eyeMaterial,pupilMaterial) {
    /* Makes and rotates an eye
     * @param params - collection of dimensions to draw Peppa
     * @param eyeMaterial - outer color of eye
     * @param pupilMaterial - inner color of eye
     * @return THREE.Object3D for the entire eye
     */
    var eyeBall = new THREE.Object3D();
    var radius = params.eyeRadius;
    var eyeGeometry = new THREE.SphereGeometry(radius,10,10);
    var eyeMesh = new THREE.Mesh(eyeGeometry, eyeMaterial);
    var pupilGeometry = new THREE.SphereGeometry(
        radius,64,32,0,Math.PI*2,0,Math.PI/6);
    var pupilMesh = new THREE.Mesh(pupilGeometry,pupilMaterial);
    eyeBall.add(eyeMesh,pupilMesh);
    eyeBall.rotation.x = params.eyeRotation;
    return eyeBall;
}

function addEye(head,params,side,eyeMaterial,pupilMaterial) {
    /* Creates and adds an eye to the head
     * @param head {THREE.Object3D} - head object
     * @param params - collection of dimensions to draw Peppa
     * @param side - specifies the side of the head to add the eye to
     *               1 for left, -1 for right
     * @param eyeMaterial - outer color of eye
     * @param pupilMaterial - inner color of eye
     */
    var eyeframe = new THREE.Object3D();
    var eye = createEye(params,eyeMaterial,pupilMaterial);
    var radius = params.headRadius;
    eye.position.z = radius;     // within the eyeframe
    var angleXL = params.eyeAngleXL;
    var angleYL = params.eyeAngleYL;
    var angleXR = params.eyeAngleXR;
    var angleYR = params.eyeAngleYR;
    if (side == 1) {
        eyeframe.rotation.x = angleXL;
        eyeframe.rotation.y = angleYL;
}
    else {
        eyeframe.rotation.x = angleXR;
        eyeframe.rotation.y = angleYR;
    }
    eyeframe.add(eye);
    head.add(eyeframe);
}

function createEar(params,material) {
    /* create and return a Mesh for an ear
     * @param params - collection of dimensions to draw Peppa
     * @param material - color of ear
     * @return THREE.Mesh for the ear */
    var radius = params.earRadius;
    var earGeometry = new THREE.SphereGeometry(radius,10,10);
    var ear = new THREE.Mesh(earGeometry, material);
    // make the ear flat like a disk
    ear.scale.z = params.earScaleZ;
    ear.scale.y = params.earScaleY;
    return ear;
}

function addEar(head,params,side,material) {
    /* Creates and adds an ear to the head
     * @param head {THREE.Object3D} - head object
     * @param params - collection of dimensions to draw Peppa
     * @param side - specifies the side of the head to add the ear to
     *               1 for left, -1 for right
     * @param material - color of ear */
    var earframe = new THREE.Object3D();
    var ear = createEar(params,material);
    var radius = params.headRadius;
    var angle = params.earAngle;
    // move the ear to the surface of the head depending on which side it is on
    if (side == 1) {
        ear.position.x = radius/1.5; // within the earframe
        ear.position.y = params.headRadius;
    }
    else {
        ear.position.x = radius/8; // within the earframe
        ear.position.y = params.headRadius*1.2;
    }
    ear.rotation.z = angle;
    earframe.add(ear);
    head.add(earframe);
    return head;
}

function createDimple(params,material) {
    /* create a dimple for peppa
     * @param params - collection of dimensions to draw Peppa
     * @param material - color of dimple 
     * @return THREE.Mesh for the dimple */
    var radius = params.headRadius;
    var dimpleGeom = new THREE.SphereGeometry(
        radius,64,32,0,Math.PI*2,0,Math.PI/10);
    var dimpleMesh = new THREE.Mesh(dimpleGeom,material);
    return dimpleMesh;
}

function addDimple(head,params,material) {
    /* Adds a dimple to the head
     * @param head {THREE.Object3D} - head object
     * @param params - collection of dimensions to draw Peppa
     * @param material - color of dimple */
    var dimpleFrame = new THREE.Object3D();
    var dimple = createDimple(params,material);
    dimpleFrame.add(dimple);
    dimpleFrame.rotation.z = params.dimpleAngleZ;
    dimpleFrame.rotation.x = params.dimpleAngleX;
   // dimpleFrame.rotation.y = params.dimpleAngleY;
    head.add(dimpleFrame);
}

function createMouth(params,material) {
    /* Create and return a Mesh for a mouth 
     * @param params - collection of dimensions for Peppa
     * @param material - color of the mouth
     * @return a Mesh for the mouth */
    var radius = params.mouthRadius;
    var mouthGeometry = new THREE.TorusGeometry(
        radius,params.mouthTube, params.mouthRadialSegment,
        params.mouthTubularSegment,params.mouthArc);
    var mouthMesh = new THREE.Mesh(mouthGeometry, material);
    mouthMesh.rotation.z = params.mouthRotationZ;
    return mouthMesh;
}

function addMouth(head,params,material) {  
    /* adds the mouth object to the head
     * @param head {THREE.Object3D} - head object
     * @param params - collection of dimensions to draw Peppa
     * @param material - color of mouth */
    var mouthFrame = new THREE.Object3D();
    var radius = params.headRadius;
    var mouth = createMouth(params,material);
    mouthFrame.add(mouth);
    mouthFrame.position.z = radius;
    mouthFrame.rotation.x = params.mouthAngleX;
    head.add(mouthFrame);
}
function createBody(params,material) {
    /* Creates the body of Peppa
     * @param params - collection of dimensions for Peppa
     * @param material - color of the body
     * @return a Mesh for the body */
    var radius = params.headRadius*1.4;
    var bodyGeom = new THREE.SphereGeometry(
        radius,64,32,0,Math.PI*2,0,Math.PI/2,true);
    var bodyMesh = new THREE.Mesh(bodyGeom,material);
    var bodyBottomGeom = new THREE.CircleGeometry(radius,32);
    var bodyBottomMesh = new THREE.Mesh(bodyBottomGeom,material);
    bodyBottomMesh.rotation.x = Math.PI/2;
    bodyMesh.add(bodyBottomMesh);
    bodyMesh.scale.y = params.bodyScaleY;
    return bodyMesh;
}

function addBody(head,body,params) {
    /* adds the body object to the head
     * @param head {THREE.Object3D} - head object
     * @param body {THREE.Mesh} - body mesh from createBody()
     * @param params - collection of dimensions for the body position */
    var bodyObj = new THREE.Object3D();
    bodyObj.add(body);
    bodyObj.position.y = -params.headRadius*2.5;
    head.add(bodyObj);
}

function createArm(params,material) {
    /* Creates an arm for Peppa, which consists of an arm and 2 fingers
     * @param params - collection containing arm measurements for Peppa
     * @param material - color of the arm
     * @return a Mesh for the arm */
    var radius = params.armRadius;
    var fingerHeight = params.fingerLength;
    var fingerPositionY = params.fingerPosY;
    var angle = params.fingerRotation;
    var mainArmGeom = new THREE.CylinderGeometry(
                        radius,radius,params.armLength,64);
    var finger1Geom = new THREE.CylinderGeometry(
                        radius,radius,fingerHeight,64);
    var finger2Geom = new THREE.CylinderGeometry(
                        radius,radius,fingerHeight,64);
    var mainArmMesh = new THREE.Mesh(mainArmGeom,material);
    var finger1Mesh = new THREE.Mesh( finger1Geom,material);
    var finger2Mesh = new THREE.Mesh(finger2Geom,material);
    var displacement = Math.sin(angle)*fingerHeight/2;
    finger1Mesh.rotation.z = angle;
    finger1Mesh.position.x = displacement;
    finger1Mesh.position.y = fingerPositionY;
    finger2Mesh.rotation.z = -angle;
    finger2Mesh.position.x = -displacement;
    finger2Mesh.position.y = fingerPositionY;
    mainArmMesh.add(finger1Mesh,finger2Mesh);
    return mainArmMesh;
}

function addArm(body,side,params,material) {
    /* adds the arm to the body
     * @param body {THREE.Mesh} - body mesh
     * @param side - specifies the side of the head to add the arm to
     *               1 for left, -1 for right
     * @param params - collection of dimensions for the arm
     * @param material - color of arm */
    var arm = createArm(params,material);
    arm.rotation.z = side*params.armRotation;
    arm.position.x = side*params.headRadius*1.5;
    arm.position.y = params.headRadius;
    body.add(arm);
    return arm;
}


function createLeg(params,bodyMaterial,shoeMaterial) {
    /* Creates a leg for Peppa
     * @param params - collection containing arm measurements for Peppa
     * @param bodyMaterial - color of the leg
     * @param shoeMaterial - color of the shoe
     * @return a Mesh for the leg */
    var radius = params.legRadius;
    var legGeom = new THREE.CylinderGeometry(
                        radius,radius,params.legHeight,64);
    var legMesh = new THREE.Mesh(legGeom,bodyMaterial);
    var shoeGeom = new THREE.SphereGeometry(params.footRadius,32,64);
    var shoeMesh = new THREE.Mesh(shoeGeom,shoeMaterial);
    shoeMesh.scale.set(params.footScaleX,params.footScaleY,params.footScaleZ);
    // shoeMesh.scale.z = params.footScaleZ;
    shoeMesh.position.set(0,-params.legHeight/2,params.footPositionZ);
    legMesh.add(shoeMesh);
    return legMesh;
}

function addLeg(body,side,params,bodyMaterial,shoeMaterial) {
    /* adds a leg to the body
     * @param body {THREE.Mesh} - body mesh
     * @param side - specifies the side of the head to add the leg to
     *               1 for left, -1 for right
     * @param params - collection of dimensions for the leg
     * @param bodyMaterial - color of the leg
     * @param shoeMaterial - color of the shoe */
    var legPositionX = params.headRadius/2;
    var legPositionY = -params.legHeight/2;
    var leg = createLeg(params,bodyMaterial,shoeMaterial);
    leg.position.set(legPositionX*side,legPositionY,0);
    body.add(leg);
}
//-----------------------------------------NANXI'S CHANGES EVERYTHING BELOW-----------------------------------
function makePeppa(params,size,bodyColor,dressColor,shoeColor) {
    /* construct a peppa pig
     * @param params - collection of dimensions
     * @param size - scale of peppa
     * @param bodyColor - color of body
     * @param dressColor - color of dress
     * @param shoeMaterial - color of the shoe 
     * @return {THREE.Object3D} peppa object */
    var bodyMaterial = new THREE.MeshBasicMaterial({color: bodyColor});
    var dressMaterial = new THREE.MeshBasicMaterial({color: dressColor});
    var shoeMaterial = new THREE.MeshBasicMaterial({color: shoeColor});
    var eyeMaterial = new THREE.MeshBasicMaterial({color: "white"});
    var mouthMaterial = new THREE.MeshBasicMaterial({color: 0xf54296});
    var dimpleMaterial = new THREE.MeshBasicMaterial({color:0xf28fce});
    var pupilMaterial = new THREE.MeshBasicMaterial({color: "black"});

    var pig = new THREE.Object3D();
    // make head
    var head = makeHead(params,bodyMaterial);
    var noseMesh = makeNose(params,bodyMaterial);
    addDimple(head,params,dimpleMaterial);
    addMouth(head,params,mouthMaterial);
    head.add(noseMesh);
    addEye(head,params,1,eyeMaterial,pupilMaterial);
    addEye(head,params,-1,eyeMaterial,pupilMaterial);
    addEar(head,params,1,bodyMaterial);
    addEar(head,params,-1,bodyMaterial);
    // create the entire body
    var body;
    //this step determines which dress global variable peppe's dress will be assigned to
    if (dressColor == 0xf5574c){
        dress1 = createBody(params,dressMaterial);
        body = dress1;
        console.log("dress1 color detected");
    }
    else if (dressColor == 0x109de8){
        dress2 = createBody(params,dressMaterial);
        body = dress2;
        console.log("dress2 color detected");
    }
    else if (dressColor == 0xed9f2b){
        dress3 = createBody(params,dressMaterial);
        body = dress3;
        console.log("dress3 color detected");
    }
    addArm(body,1,params,bodyMaterial);
    addArm(body,-1,params,bodyMaterial);
    addLeg(body,1,params,bodyMaterial,shoeMaterial);
    addLeg(body,-1,params,bodyMaterial,shoeMaterial);
    // add the completed body to the head
    addBody(head,body,params,dressMaterial);
    pig.add(head);
    return pig;
}



// peppa at the center
var peppaPig = makePeppa(params,1,0xf2a5c9,0xf5574c,"black");
peppaPig.position.set(params.peppa0X, params.peppa0Y, params.peppa0Z);

//peppa on the left
var peppaPig1 = makePeppa(params,1,0xf2a5c9,0x109de8,"black");
peppaPig1.rotation.y = params.peppa1Rotation;
peppaPig1.position.set(params.peppa1X, params.peppa1Y, params.peppa1Z);

//peppa on the right
var peppaPig2 = makePeppa(params,1,0xf2a5c9,0xed9f2b,"black");
peppaPig2.position.set(params.peppa2X, params.peppa2Y, params.peppa2Z);
peppaPig2.rotation.y = params.peppa2Rotation;

//add the figures to the market stand
marketStand.add(peppaPig,peppaPig1,peppaPig2);

marketStand.position.set(0,-40,0);
scene.add(marketStand);


function displayBackground(textures){
    textures[3].wrapS = THREE.MirroredRepeatWrapping;
    textures[3].wrapT = THREE.MirroredRepeatWrapping;
    textures[3].repeat.set(4,4);
    textures[3].needsUpdate = true;
    textures[2].wrapS = THREE.MirroredRepeatWrapping;
    textures[2].wrapT = THREE.RepeatWrapping;
    textures[2].repeat.set(1,1);
    textures[2].needsUpdate = true;
    textures[4].wrapS = THREE.MirroredRepeatWrapping;
    textures[4].wrapT = THREE.RepeatWrapping;
    textures[4].repeat.set(1,1);
    textures[5].wrapS = THREE.MirroredRepeatWrapping;
    textures[5].wrapT = THREE.RepeatWrapping;
    textures[5].repeat.set(1,1);
    textures[6].wrapS = THREE.MirroredRepeatWrapping;
    textures[6].wrapT = THREE.RepeatWrapping;
    textures[6].repeat.set(1,1);
    textures[7].wrapS = THREE.MirroredRepeatWrapping;
    textures[7].wrapT = THREE.RepeatWrapping;
    textures[7].repeat.set(1,1);
    textures[8].wrapS = THREE.MirroredRepeatWrapping;
    textures[8].wrapT = THREE.RepeatWrapping;
    textures[8].repeat.set(1,1);
    textures[9].wrapS = THREE.MirroredRepeatWrapping;
    textures[9].wrapT = THREE.RepeatWrapping;
    textures[9].repeat.set(1,1);
    textures[10].wrapS = THREE.MirroredRepeatWrapping;
    textures[10].wrapT = THREE.RepeatWrapping;
    textures[10].repeat.set(1,1);
    textures[11].wrapS = THREE.MirroredRepeatWrapping;
    textures[11].wrapT = THREE.RepeatWrapping;
    textures[11].repeat.set(1,1);
    textures[12].wrapS = THREE.MirroredRepeatWrapping;
    textures[12].wrapT = THREE.RepeatWrapping;
    textures[12].repeat.set(1,1);
    textures[13].wrapS = THREE.MirroredRepeatWrapping;
    textures[13].wrapT = THREE.RepeatWrapping;
    textures[13].repeat.set(1,1);
    textures[14].wrapS = THREE.MirroredRepeatWrapping;
    textures[14].wrapT = THREE.RepeatWrapping;
    textures[14].repeat.set(1,1);
    var planeGeom = new THREE.PlaneGeometry(600,400);;
    var planeMat = new THREE.MeshBasicMaterial( {color:0xffffff,map:textures[2]} );
    var planeMesh = new THREE.Mesh(planeGeom, planeMat);
    //adding the neon lights to the background
    //create meshs for the neon lights
    var neon1Geom = new THREE.PlaneGeometry(50,50);
    var neon1Mat = new THREE.MeshBasicMaterial({color:0xffffff,map:textures[4]});
    var neon1Mesh = new THREE.Mesh(neon1Geom,neon1Mat);
    neon1Mesh.position.set(50,50,1);

    var neon2Geom = new THREE.PlaneGeometry(80,50);
    var neon2Mat = new THREE.MeshBasicMaterial({color:0xffffff,map:textures[5]});
    var neon2Mesh = new THREE.Mesh(neon2Geom,neon2Mat);
    neon2Mesh.position.set(75,0,1);

    var neon3Geom = new THREE.PlaneGeometry(40,50);
    var neon3Mat = new THREE.MeshBasicMaterial({color:0xffffff,map:textures[6]});
    var neon3Mesh = new THREE.Mesh(neon3Geom,neon3Mat);
    neon3Mesh.position.set(-90,60,1);

    var neon4Geom = new THREE.PlaneGeometry(60,30);
    var neon4Mat = new THREE.MeshBasicMaterial({color:0xffffff,map:textures[7]});
    var neon4Mesh = new THREE.Mesh(neon4Geom,neon4Mat);
    neon4Mesh.position.set(-120,30,1.5);

    var neon5Geom = new THREE.PlaneGeometry(50,50);
    var neon5Mat = new THREE.MeshBasicMaterial({color:0xffffff,map:textures[8]});
    var neon5Mesh = new THREE.Mesh(neon5Geom,neon5Mat);
    neon5Mesh.position.set(130,50,1);

    var neon6Geom = new THREE.PlaneGeometry(70,25);
    var neon6Mat = new THREE.MeshBasicMaterial({color:0xffffff,map:textures[9]});
    var neon6Mesh = new THREE.Mesh(neon6Geom,neon6Mat);
    neon6Mesh.position.set(-150,-10,1);

    planeMesh.add(neon1Mesh,neon2Mesh,neon3Mesh,neon4Mesh,neon5Mesh,neon6Mesh);
    planeMesh.position.set(0,150,-80);
    var groundGeom = new THREE.PlaneGeometry(1000,400);
    var groundMat = new THREE.MeshBasicMaterial({color: 0xffffff,
                                                 map: textures[3]});
    var groundMesh = new THREE.Mesh(groundGeom,groundMat);
    groundMesh.rotation.x = -Math.PI/2;
    groundMesh.position.y = -50;
    scene.add(planeMesh,groundMesh);

}
var nframes = 0;
//runTimer makes peppa dance for 12 frames
function runTimer () {
    if (peppa != null) {
        scene.remove(peppa);
    }
    //change peppa's leg and arm parameters in params
    params.peppaPosX += danceX[nframes];
    params.peppaPosY += danceY[nframes];
    peppa = makePeppa(params,1,0xf2a5c9,params.peppaDressColor,"black");
    peppa.position.set(params.peppaPosX, params.peppaPosY, params.peppaPosZ);
    peppa.rotation.y = params.peppaRotation;
    scene.add(peppa);
    nframes += 1;
    console.log("nframes:",nframes);
    if (nframes > 12) {
        clearInterval(clock);        // stop the timer started with setInterval()
        nframes = 0;
        //this step restores the peppa that has been removed from the scene
        if(params.peppaDressColor == params.peppa0Color){
            peppaPig = makePeppa(params,1,0xf2a5c9,0xf5574c,"black");
            peppaPig.position.set(params.peppa0X, params.peppa0Y, params.peppa0Z);
            marketStand.add(peppaPig);
            console.log("peppa0 RESTORED");
        }
        else if(params.peppaDressColor == params.peppa1Color){
            peppaPig1 = makePeppa(params,1,0xf2a5c9,0x109de8,"black");
            peppaPig1.rotation.y = params.peppa1Rotation;
            peppaPig1.position.set(params.peppa1X, params.peppa1Y, params.peppa1Z);
            marketStand.add(peppaPig1);
            console.log("peppa1 RESTORED");
        }
        else if(params.peppaDressColor == params.peppa2Color){
            peppaPig2 = makePeppa(params,1,0xf2a5c9,0xed9f2b,"black");
            peppaPig2.position.set(params.peppa2X, params.peppa2Y, params.peppa2Z);
            peppaPig2.rotation.y = params.peppa2Rotation;
            marketStand.add(peppaPig2);
            console.log("peppa2 RESTORED");
        }
        render();
    } else {
        render();
    }
}

//MOUSE CLICK --- USER INTERACTION
document.addEventListener('click', onClick, false);

// raycasting is used to determine which objects in the 3D space map to the mouse click location

var raycaster = new THREE.Raycaster();
var mouse = new THREE.Vector2();

// global variable assigned to canvas element

var c1 = renderer.domElement;
//onClick adds the function that enables the user to click on one of the figures' dresses and make it dance
function onClick (event) {  
   if (event.target == c1) {
      // use canvas offset to determine mouse coordinates in canvas coordinate frame
      var rect = event.target.getBoundingClientRect();
      var canvasX = event.clientX - rect.left;
      var canvasY = event.clientY - rect.top;
   } else {
      return;
   }
   // get mouse coordinates in the range from -1 to +1 (canvas is 800 x 500 pixels)
   mouse.x = (canvasX / 800) * 2 - 1;
   mouse.y = -(canvasY / 500) * 2 + 1;
   // setup raycaster using mouse position and camera
   raycaster.setFromCamera(mouse, camera);
   // get array of objects projecting to this mouse position, recursively
   // checking all descendants of each object in the scene
   var intersects = raycaster.intersectObjects(scene.children, true);
   console.log(intersects.length);
   if (intersects.length > 0) {
      peppa = intersects[0].object;
      //this step determines which peppa has been clicked on
      if(peppa == dress1){
          peppa = peppaPig;
          params.peppaPosX = params.peppa0X;
          params.peppaPosY = -10;
          params.peppaPosZ = params.peppa0Z;
          params.peppaDressColor = params.peppa0Color;
          params.peppaRotation = params.peppa0Rotation;
          console.log("clicked on peppaPigMiddle");
          marketStand.remove(peppaPig);
          clock = setInterval(runTimer,500);
      }
      else if(peppa == dress2){
          peppa = peppaPig1;
          params.peppaPosX = params.peppa1X;
          params.peppaPosY = -10;
          params.peppaPosZ = params.peppa1Z;
          params.peppaDressColor = params.peppa1Color;
          params.peppaRotation = params.peppa1Rotation;
          console.log("clicked on peppaPigLeft");
          marketStand.remove(peppaPig1);
          clock = setInterval(runTimer,500);
      }
      else if (peppa == dress3){
          peppa = peppaPig2;
          params.peppaPosX = params.peppa2X;
          params.peppaPosY = -10;
          params.peppaPosZ = params.peppa2Z;
          params.peppaDressColor = params.peppa2Color;
          params.peppaRotation = params.peppa2Rotation;
          console.log("clicked on peppaPigRight");
          marketStand.remove(peppaPig2);
          clock = setInterval(runTimer,500);
      }
      renderer.render(scene, camera);
   }
}

// ================
//CAMERA
// ================

var cameraParams = {
    near: 5,
    far: 500,
    fov: 90,                  // degrees
    aspectRatio: 800.0/500.0, // from canvas dimensions, see CSS
    atX: 0,
    atY: 50,
    atZ: 0,
    eyeX: 0,
    eyeY: 50,
    eyeZ: 200,
    upX: 0,
    upY: 1,
    upZ: 0
};
//SET UP THE CAMERA
function setupCamera (cameraParameters) {
    // set up an abbreviation 
    var cp = cameraParameters;
    // create an initial camera with the desired shape
    var camera = new THREE.PerspectiveCamera(cp.fov,
                                             cp.aspectRatio,
                                             cp.near,
                                             cp.far);
    // set the camera location and orientation
    camera.position.set(cp.eyeX, cp.eyeY, cp.eyeZ);
    camera.up.set(cp.upX, cp.upY, cp.upZ);
    camera.lookAt(new THREE.Vector3(cp.atX, cp.atY, cp.atZ));

    return camera;
}
var camera = setupCamera(cameraParams);
scene.add(camera);
function render() {
    // assume global variables scene, renderer, and camera
    renderer.render(scene,camera);
}

// ===================
// textures
// ===================
TW.loadTextures(["sign.png", "bg.png","alley1.jpg","bricks.jpg","neon1.jpg","neon2.jpg","neon3.jpg","neon4.jpg","neon5.jpeg","neon6.jpg",
"neon7.jpeg","neon8.jpg","neon9.jpg","neon10.jpg","neon11.jpg"], 
                function (textures) {
                    textureGlobal = textures;
                    createSign(textures);
                    displayBackground(textures);
                    render();
                } );

// ===================
// lighting
// ===================
var ambLight = new THREE.AmbientLight(0xffffff);
scene.add(ambLight);

var dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
dirLight.position.set(0, params.poleHeight, 
                        params.tableDepth/2 - params.signDepth / 2);
dirLight.target.position.set(0, 0, -params.tableDepth/16);
scene.add(dirLight);
scene.add(dirLight.target);



</script>
</body>
</html>