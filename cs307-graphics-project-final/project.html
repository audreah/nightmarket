<!doctype html>
<!-- 
Name: Audrea Huang and Nanxi Liu
CS 307 Final Project
Date: May 16, 2022
Creates an image of a nightmarket food stand.
-->
<html lang="en">
<head>
<meta charset="utf-8">
<title>Nightmarket</title>
<style>      
    canvas {
        display: block;
        margin: 10px auto;
        width: 800px;
        height: 500px;
    }
</style>

<script src="https://cs.wellesley.edu/~cs307/threejs/libs/three-r95.all.js">
"https://cs.wellesley.edu/~cs307/threejs/libs/three-r80.min.js"
</script>
<script src="https://cs.wellesley.edu/~cs307/threejs/libs/OrbitControls-r95.js">
"https://cs.wellesley.edu/~cs307/threejs/libs/OrbitControls.js"
</script>
<script src="https://cs.wellesley.edu/~cs307/threejs/libs/tw-sp21.js">
"https://cs.wellesley.edu/~cs307/threejs/libs/tw-fa18.js"
</script>
<script src="https://cs.wellesley.edu/~cs307/threejs/libs/dat.gui-r95.js">
"https://cs.wellesley.edu/~cs307/threejs/libs/dat.gui.min.js"
</script>

</head>
<body style="background-color:#181b1c">
<h1 style="color:white; text-align: center;">Nightmarket</h1>
<div style="word-wrap:break-word; max-width:50%; text-align: center;">
    <p style="color:white; margin: 0 auto 0 0;">
        <b>Name</b>: Nanxi Liu and Audrea Huang<br>
        <b>CS 307 Final Project</b><br>
        <b>Date</b>: May 16, 2022<br>
        <b>Description</b>: Welcome to our night market candy stand!
            To toggle the music on and off, click the sound
            icon at the top right corner within the semi-transparent box. 
            To make the figures dance, click on their dresses. 
            The figures can only dance one at a time.
    <br></p>
</div>

<script id="prog">
//the two dance arrays determine peppa's dance moves
var danceX = [2,1,-3,0,5,10,-5,6,6,0,1,-23];
var danceY = [1,2,3,4,0,5,-1,-2,-3,0,-4,-5];
var params = {
    poleRadius: 2,
    poleHeight: 50,
    tableWidth: 150,
    tableHeight: 20,
    tableDepth: 45,
    signHeight: 20,
    signDepth: 10,
    candyStickHeight: 8,
    //params for arms
    armRadius:0.5,
    armLength:12,
    armRotation:Math.PI/1.5,
    fingerLength:4,
    fingerRotation: Math.PI/6,
    fingerPosY: -3,
    //params for legs
    legRadius: 0.5,
    legHeight: 5,
    legRotation:0,
    footRadius: 0.5,
    footScaleX: 1,
    footScaleY: 0.5,
    footScaleZ: 2,
    footPositionZ: 1.5,
    footPositionY: -7.5,
    headRadius: 10,
    noseHeight:15,
    noseRadiusTop:4,
    noseRadiusBottom:8,
    noseRotationZ: 1,
    nosePositionX: -8,
    nosePositionY:7,
    bodyScaleY: 1.5,
    dimpleAngleX: Math.PI/2,
    dimpleAngleZ: -Math.PI/5,
    eyeRadius:1.5,
    eyeAngleXL: -Math.PI/4,
    eyeAngleYL: -Math.PI/10,
    eyeAngleXR: -Math.PI/6,
    eyeAngleYR: Math.PI/20,//Math.PI/10,
    eyeRotation:Math.PI*0.7,
    earRadius: 2,
    earScaleY: 2,
    earScaleZ:0.5,
    earAngle: -Math.PI/8,
    mouthRadius: 4,
    mouthAngleX: Math.PI/20,
    mouthRotationZ: Math.PI*0.99,
    mouthTube: 0.35,
    mouthRadialSegment: 10,
    mouthTubularSegment: 200,
    mouthArc: 2.4,
    armLength:10,
    fingerLength:3,
    legLength:8,
    footRadius:2,
    footStretchZ:1.5,
    //parameters FOR ANIMATION
    direction:1,
    rotationZ:0,
    dz:Math.PI/2,
    peppaPosX: 40,
    peppaPosY:-10,
    peppaPosZ:50,
    peppaRotation:0,
    /*@params parameters for peppa on the left*/
    peppa1X: -150,
    peppa1Y: 30,
    peppa1Z: 45,
    peppa1Color: 0x109de8,
    peppa1Rotation:Math.PI/4,
    /*@params parameters for peppa on the right*/
    peppa2X: 150,
    peppa2Y: 30,
    peppa2Z: 70,
    peppa2Color: 0xed9f2b,
    peppa2Rotation:-Math.PI/4,
    /*@params parameters for peppa in the middle*/
    peppa0X:0,
    peppa0Y: 30,
    peppa0Z: -45,
    peppa0Color: 0xf5574c,
    peppa0Rotation:0,
    peppaDressColor:0
}

//peppa is the global variable name for the object that's been clicked on
//the 3 dress variables are the global variable names for the figures' dresses, which the users can click on to make the figures dance.
var peppa, clock;
var dress1,dress2,dress3;

var textureGlobal; // textures for mapping images
var scene = new THREE.Scene(); 
scene.background = new THREE.Color( 0x15161A );
var renderer = new THREE.WebGLRenderer();
TW.mainInit(renderer,scene);


// ================
// CAMERA
// ================

var cameraParams = {
    near: 5,
    far: 500,
    fov: 90,                  // degrees
    aspectRatio: 800.0/500.0, // from canvas dimensions, see CSS
    atX: 0,
    atY: 20,
    atZ: 30,
    eyeX: 0,
    eyeY: 20,
    eyeZ: 230,
    upX: 0,
    upY: 1,
    upZ: 0
};
// SET UP THE CAMERA
function setupCamera (cameraParameters) {
    // set up an abbreviation 
    var cp = cameraParameters;
    // create an initial camera with the desired shape
    var camera = new THREE.PerspectiveCamera(cp.fov,
                                             cp.aspectRatio,
                                             cp.near,
                                             cp.far);
    // set the camera location and orientation
    camera.position.set(cp.eyeX, cp.eyeY, cp.eyeZ);
    camera.up.set(cp.upX, cp.upY, cp.upZ);
    camera.lookAt(new THREE.Vector3(cp.atX, cp.atY, cp.atZ));

    return camera;
}

var camera = setupCamera(cameraParams);
scene.add(camera);
function render() {
    // assume global variables scene, renderer, and camera
    renderer.render(scene,camera);
}

// ================
// Food Stand
// ================
var table = new THREE.Object3D();

// create a box for the table
var tableGeom = new THREE.BoxGeometry(
                    params.tableWidth, params.tableHeight, params.tableDepth);
var tableMat = new THREE.MeshPhongMaterial({color: new THREE.Color("gray")});
var tableMesh = new THREE.Mesh(tableGeom, tableMat);

table.add(tableMesh);

// create the poles for the table
var pole = new THREE.CylinderGeometry( params.poleRadius,
                                        params.poleRadius,
                                        params.poleHeight );

var poleMat = new THREE.MeshPhongMaterial({color:new THREE.Color("grey")});
var poleMesh1 = new THREE.Mesh(pole,poleMat); // left
var poleMesh2 = new THREE.Mesh(pole,poleMat); // right

// set the position of the poles
poleMesh1.position.set( -params.tableWidth/2 + params.poleRadius,
                        params.poleHeight/2,
                        params.tableDepth/2 - params.poleRadius );

poleMesh2.position.set( params.tableWidth/2 - params.poleRadius,
                        params.poleHeight/2,
                        params.tableDepth/2-params.poleRadius );
table.add(poleMesh1);
table.add(poleMesh2);

function addTextureCoords (geom, textures) {
    /* add coordinates to map textures onto */
    if( ! geom instanceof THREE.Geometry ) {
        throw "not a THREE.Geometry: "+geom;
    }
    // array of face descriptors
    var UVs = [];
    function faceCoords(as,at, bs,bt, cs,ct) {
        UVs.push( [ new THREE.Vector2(as,at),
                    new THREE.Vector2(bs,bt),
                    new THREE.Vector2(cs,ct) ] );
    }
    // right (face 0-1)
    faceCoords(1,0, 0,0, 1,1);
    faceCoords(1,1, 0,0, 0,1);
    // left (faces 2-3)
    faceCoords(1,0, 0,1, 0,0);
    faceCoords(1,0, 1,1, 0,1);
    // top (faces 4-5)
    faceCoords(1,1, 1,0, 0,1);
    faceCoords(0,1, 1,1, 1,0);
    // bottom (faces 6-7)
    faceCoords(1,1, 1,1, 0,0);
    faceCoords(1,1, 0,1, 0,0);
    // front (faces 8-9)
    faceCoords(0,1, 0,0, 1,1);
    faceCoords(0,0, 1,0, 1,1);
    // back (faces 10-11)
    faceCoords(0,0, 1,0, 0,1);
    faceCoords(1,0, 1,1, 0,1);

    // attach this to the geometry
    geom.faceVertexUvs = [ UVs ];
}

function createSignLight() {
    /* Creates a single lightbulb to be placed on the perimeter of the sign
        * @return object for the lightbulb, which includes the bulb and the light */
    var lightbulbObj = new THREE.Object3D();

    var lightbulbGeom = new THREE.SphereGeometry(params.signLightRadius);
    var lightMaterial = new THREE.MeshPhongMaterial({color: 0xf6d0a5});
    var lightbulb = new THREE.Mesh(lightbulbGeom, lightMaterial);
    lightbulbObj.add(lightbulb);

    var light = new THREE.PointLight(0xffffff, 1, params.signHeight);
    lightbulbObj.add( light );
    return lightbulbObj;
}

var signObj = new THREE.Object3D();

function addSignLightsTB(x, dx, y, z, numLights) {
    /* adds the lights along the top and bottom of the sign 
     * recursively by adding one each time and shifting the 
     * position for the next one, starting at the top left corner 
     * @param x - x coordinate of the current bulb
     * @param dx - change in x position to add the next bulb
     * @param y - y coordinate of the current bulb
     * @param z - z coordinate as the sign's depth 
     * @param numLights - number of bulbs */

    if (numLights > 0) {
        var lightTop = createSignLight();
        lightTop.position.set(x,y,z);
        signObj.add(lightTop);
        addSignLightsTB(x+dx, dx, y, z, numLights-1);
        var lightBottom = createSignLight();
        lightBottom.position.set(x,-y,z);
        signObj.add(lightBottom);
    } 
}

function addSignLightsLR(x, y, dy, z, numLights) {
    /* adds the lights along the left and right sides of the sign 
     * recursively by adding one each time and shifting the 
     * position for the next one, starting at the top left corner 
     * @param x - x coordinate of the current bulb
     * @param y - y coordinate of the current bulb
     * @param dy - change in y position to add the next bulb
     * @param z - z coordinate as the sign's depth 
     * @param numLights - number of bulbs */

    if (numLights > 0) {
        var lightRight = createSignLight();
        lightRight.position.set(x,y,z);
        signObj.add(lightRight);

        addSignLightsLR(x, y+dy, dy, z, numLights-1);

        var lightLeft = createSignLight();
        lightLeft.position.set(-x,y,z);
        signObj.add(lightLeft);
    }
}

function createSign() {
    /* Create the sign for the nightmarket stand, which consists of a box
     * for the backing, text for the name in Chinese of the contents being
     * sold, and lights along the perimeter.
     * @param textures - list of textures */
    // var signObj = new THREE.Object3D();

    var signGeom = new THREE.BoxGeometry(
        params.tableWidth, params.signHeight, params.signDepth);
    var signMat = new THREE.MeshPhongMaterial({color: 0x430d03});
    var signMesh = new THREE.Mesh(signGeom, signMat);
    signObj.add(signMesh);

    /* Add lights around the sign. The spacing between each pair of lights 
     * is calculated with respect to the size and number of lights */
    var numLightsTB = 10; // number of lights on the top and bottom of the sign
    var dx = (params.tableWidth - numLightsTB*params.signLightRadius) / 
             (numLightsTB-1);
    // start adding lights at the top left corner
    addSignLightsTB(-params.tableWidth/2 + params.signLightRadius, dx, 
        params.signHeight/2-params.signLightRadius, 
        params.signDepth/2+1, numLightsTB);

    // add lights on the left and right sides of the sign
    var numLightsLR = 1;
    // the vertical spacing between the lights is the amount of the sign's
    // height that is not occupied by lightbulbs
    var dy = (params.signHeight - (numLightsLR+2)*params.signLightRadius) /
             (numLightsLR+1);
    // start with the lower right bulb
    addSignLightsLR(params.tableWidth/2-params.signLightRadius,
        -params.signHeight/2 + params.signLightRadius*2 + dy, dy,
        params.signDepth/2+1, numLightsLR);

    // create the text for the sign
    var loader = new THREE.FontLoader();

    loader.load(
        'font.json',
        function (font) {
            var textGeom = new THREE.TextGeometry('糖葫蘆', 
                                                { font: font,
                                                size: 11,
                                                height: 2 } );
            var textMat = new THREE.MeshBasicMaterial({color: 0xf6d0a5});
            var textMesh = new THREE.Mesh(textGeom, textMat);
            textMesh.position.set(-params.tableWidth/6, 
                -params.signHeight/4, params.signDepth/2);
            signObj.add(textMesh);
            render();
        } );

    signObj.position.set(0, params.poleHeight + params.signHeight / 2,
        params.tableDepth / 2 - params.signDepth / 4);
    table.add(signObj);
}

createSign();

var pointLight = new THREE.PointLight(color=0xffffff, intensity=1, distance=params.tableWidth);
pointLight.position.set( 0, params.poleHeight + params.signHeight / 2,
        params.tableDepth / 2);
// scene.add( pointLight );

// create an object for the stand as a whole so it is easier to move
// origin is at center of table
var marketStand = new THREE.Object3D();
marketStand.add(table);


// ===================
// food
// ===================

function createStick() {
    /* Creates the stick for the candy. */
    var stickGeom = new THREE.CylinderGeometry(
                        0.2, 0.2, params.candyStickHeight);
    var stickMat = new THREE.MeshPhongMaterial(
        {color:new THREE.Color(0x877d61)});
    var stickMesh = new THREE.Mesh(stickGeom, stickMat);
    return stickMesh;
}

function createBall() {
    /* Creates one of the red spherical candies. */
    var ballGeom = new THREE.SphereGeometry(1);
    var ballMat = new THREE.MeshPhongMaterial(
        {color:new THREE.Color("red"), side: THREE.DoubleSide});
    var ballMesh = new THREE.Mesh(ballGeom, ballMat);
    return ballMesh;
}

function createCandy() {
    /* Creates one instance of an entire candy, consisting of 
     * a stick and red candies.
     @return candy object */

    var candy = new THREE.Object3D();
    candy.add(createStick());
    ball1 = createBall();
    ball1.position.y = -params.candyStickHeight/2 + 5;
    candy.add(ball1);

    ball2 = createBall();
    ball2.position.y = -params.candyStickHeight/2 + 7;
    candy.add(ball2);

    ball2 = createBall();
    ball2.position.y = -params.candyStickHeight/2 + 9;
    candy.add(ball2);

    return candy;
}

// add candies to the stand
for (var j=0; j<10; j++) {
    // add candies on the left side of the table
    var candyL = createCandy();
    table.add(candyL);
    // increase position to the left
    candyL.position.set(
        j*-5 - params.tableDepth/3, 
        params.tableHeight/2 + params.candyStickHeight/2, 
        params.tableDepth/2);

    // add candies on the right
    var candyR = createCandy();
    table.add(candyR);
    candyR.position.set(
        j*5 + params.tableDepth/4, 
        params.tableHeight/2 + params.candyStickHeight/2, 
        params.tableDepth/2);
}

// ===================
// add peppa pig
// ====================
function makeHead(params,material) {
    /* Make a head for Peppa 
     * @param params - collection of dimensions to draw Peppa
     * @param material - color of head
     * @return THREE.Object3D for the head
     */
    var head = new THREE.Object3D();
    var headGeom = new THREE.SphereGeometry(params.headRadius,32,16);
    var headMesh = new THREE.Mesh(headGeom,material);
    head.add(headMesh);
    return head
}

function makeNose(params,material) {
    /* Makes, positions, and rotates a nose
     * @param params - collection of dimensions to draw Peppa
     * @param material - color of nose
     * @return THREE.Mesh for the nose
     */
    var noseGeom = new THREE.CylinderGeometry(
        params.noseRadiusTop,params.noseRadiusBottom,params.noseHeight);
    var noseMesh = new THREE.Mesh(noseGeom,material);
    noseMesh.position.set(params.nosePositionX,params.nosePositionY,0);
    noseMesh.rotation.z = params.noseRotationZ;
    return noseMesh
}

function createEye(params,eyeMaterial,pupilMaterial) {
    /* Makes and rotates an eye
     * @param params - collection of dimensions to draw Peppa
     * @param eyeMaterial - outer color of eye
     * @param pupilMaterial - inner color of eye
     * @return THREE.Object3D for the entire eye
     */
    var eyeBall = new THREE.Object3D();
    var radius = params.eyeRadius;
    var eyeGeometry = new THREE.SphereGeometry(radius,10,10);
    var eyeMesh = new THREE.Mesh(eyeGeometry, eyeMaterial);
    var pupilGeometry = new THREE.SphereGeometry(
        radius,64,32,0,Math.PI*2,0,Math.PI/6);
    var pupilMesh = new THREE.Mesh(pupilGeometry,pupilMaterial);
    eyeBall.add(eyeMesh,pupilMesh);
    eyeBall.rotation.x = params.eyeRotation;
    return eyeBall;
}

function addEye(head,params,side,eyeMaterial,pupilMaterial) {
    /* Creates and adds an eye to the head
     * @param head {THREE.Object3D} - head object
     * @param params - collection of dimensions to draw Peppa
     * @param side - specifies the side of the head to add the eye to
     *               1 for left, -1 for right
     * @param eyeMaterial - outer color of eye
     * @param pupilMaterial - inner color of eye
     */
    var eyeframe = new THREE.Object3D();
    var eye = createEye(params,eyeMaterial,pupilMaterial);
    var radius = params.headRadius;
    eye.position.z = radius;     // within the eyeframe
    var angleXL = params.eyeAngleXL;
    var angleYL = params.eyeAngleYL;
    var angleXR = params.eyeAngleXR;
    var angleYR = params.eyeAngleYR;
    if (side == 1) {
        eyeframe.rotation.x = angleXL;
        eyeframe.rotation.y = angleYL;
}
    else {
        eyeframe.rotation.x = angleXR;
        eyeframe.rotation.y = angleYR;
    }
    eyeframe.add(eye);
    head.add(eyeframe);
}

function createEar(params,material) {
    /* create and return a Mesh for an ear
     * @param params - collection of dimensions to draw Peppa
     * @param material - color of ear
     * @return THREE.Mesh for the ear */
    var radius = params.earRadius;
    var earGeometry = new THREE.SphereGeometry(radius,10,10);
    var ear = new THREE.Mesh(earGeometry, material);
    // make the ear flat like a disk
    ear.scale.z = params.earScaleZ;
    ear.scale.y = params.earScaleY;
    return ear;
}

function addEar(head,params,side,material) {
    /* Creates and adds an ear to the head
     * @param head {THREE.Object3D} - head object
     * @param params - collection of dimensions to draw Peppa
     * @param side - specifies the side of the head to add the ear to
     *               1 for left, -1 for right
     * @param material - color of ear */
    var earframe = new THREE.Object3D();
    var ear = createEar(params,material);
    var radius = params.headRadius;
    var angle = params.earAngle;
    // move the ear to the surface of the head depending on which side it is on
    if (side == 1) {
        ear.position.x = radius/1.5; // within the earframe
        ear.position.y = params.headRadius;
    }
    else {
        ear.position.x = radius/8; // within the earframe
        ear.position.y = params.headRadius*1.2;
    }
    ear.rotation.z = angle;
    earframe.add(ear);
    head.add(earframe);
    return head;
}

function createDimple(params,material) {
    /* create a dimple for peppa
     * @param params - collection of dimensions to draw Peppa
     * @param material - color of dimple 
     * @return THREE.Mesh for the dimple */
    var radius = params.headRadius;
    var dimpleGeom = new THREE.SphereGeometry(
        radius,64,32,0,Math.PI*2,0,Math.PI/10);
    var dimpleMesh = new THREE.Mesh(dimpleGeom,material);
    return dimpleMesh;
}

function addDimple(head,params,material) {
    /* Adds a dimple to the head
     * @param head {THREE.Object3D} - head object
     * @param params - collection of dimensions to draw Peppa
     * @param material - color of dimple */
    var dimpleFrame = new THREE.Object3D();
    var dimple = createDimple(params,material);
    dimpleFrame.add(dimple);
    dimpleFrame.rotation.z = params.dimpleAngleZ;
    dimpleFrame.rotation.x = params.dimpleAngleX;
   // dimpleFrame.rotation.y = params.dimpleAngleY;
    head.add(dimpleFrame);
}

function createMouth(params,material) {
    /* Create and return a Mesh for a mouth 
     * @param params - collection of dimensions for Peppa
     * @param material - color of the mouth
     * @return a Mesh for the mouth */
    var radius = params.mouthRadius;
    var mouthGeometry = new THREE.TorusGeometry(
        radius,params.mouthTube, params.mouthRadialSegment,
        params.mouthTubularSegment,params.mouthArc);
    var mouthMesh = new THREE.Mesh(mouthGeometry, material);
    mouthMesh.rotation.z = params.mouthRotationZ;
    return mouthMesh;
}

function addMouth(head,params,material) {  
    /* adds the mouth object to the head
     * @param head {THREE.Object3D} - head object
     * @param params - collection of dimensions to draw Peppa
     * @param material - color of mouth */
    var mouthFrame = new THREE.Object3D();
    var radius = params.headRadius;
    var mouth = createMouth(params,material);
    mouthFrame.add(mouth);
    mouthFrame.position.z = radius;
    mouthFrame.rotation.x = params.mouthAngleX;
    head.add(mouthFrame);
}

function createBody(params,material) {
    /* Creates the body of Peppa
     * @param params - collection of dimensions for Peppa
     * @param material - color of the body
     * @return a Mesh for the body */
    var radius = params.headRadius*1.4;
    var bodyGeom = new THREE.SphereGeometry(
        radius,64,32,0,Math.PI*2,0,Math.PI/2,true);
    var bodyMesh = new THREE.Mesh(bodyGeom,material);
    var bodyBottomGeom = new THREE.CircleGeometry(radius,32);
    var bodyBottomMesh = new THREE.Mesh(bodyBottomGeom,material);
    bodyBottomMesh.rotation.x = Math.PI/2;
    bodyMesh.add(bodyBottomMesh);
    bodyMesh.scale.y = params.bodyScaleY;
    return bodyMesh;
}

function addBody(head,body,params) {
    /* adds the body object to the head
     * @param head {THREE.Object3D} - head object
     * @param body {THREE.Mesh} - body mesh from createBody()
     * @param params - collection of dimensions for the body position */
    var bodyObj = new THREE.Object3D();
    bodyObj.add(body);
    bodyObj.position.y = -params.headRadius*2.5;
    head.add(bodyObj);
}

function createArm(params,material) {
    /* Creates an arm for Peppa, which consists of an arm and 2 fingers
     * @param params - collection containing arm measurements for Peppa
     * @param material - color of the arm
     * @return a Mesh for the arm */
    var radius = params.armRadius;
    var fingerHeight = params.fingerLength;
    var fingerPositionY = params.fingerPosY;
    var angle = params.fingerRotation;
    var mainArmGeom = new THREE.CylinderGeometry(
                        radius,radius,params.armLength,64);
    var finger1Geom = new THREE.CylinderGeometry(
                        radius,radius,fingerHeight,64);
    var finger2Geom = new THREE.CylinderGeometry(
                        radius,radius,fingerHeight,64);
    var mainArmMesh = new THREE.Mesh(mainArmGeom,material);
    var finger1Mesh = new THREE.Mesh( finger1Geom,material);
    var finger2Mesh = new THREE.Mesh(finger2Geom,material);
    var displacement = Math.sin(angle)*fingerHeight/2;
    finger1Mesh.rotation.z = angle;
    finger1Mesh.position.x = displacement;
    finger1Mesh.position.y = fingerPositionY;
    finger2Mesh.rotation.z = -angle;
    finger2Mesh.position.x = -displacement;
    finger2Mesh.position.y = fingerPositionY;
    mainArmMesh.add(finger1Mesh,finger2Mesh);
    return mainArmMesh;
}

function addArm(body,side,params,material) {
    /* adds the arm to the body
     * @param body {THREE.Mesh} - body mesh
     * @param side - specifies the side of the head to add the arm to
     *               1 for left, -1 for right
     * @param params - collection of dimensions for the arm
     * @param material - color of arm */
    var arm = createArm(params,material);
    arm.rotation.z = side*params.armRotation;
    arm.position.x = side*params.headRadius*1.5;
    arm.position.y = params.headRadius;
    body.add(arm);
}

function createLeg(params,bodyMaterial,shoeMaterial) {
    /* Creates a leg for Peppa
     * @param params - collection containing arm measurements for Peppa
     * @param bodyMaterial - color of the leg
     * @param shoeMaterial - color of the shoe
     * @return a Mesh for the leg */
    var radius = params.legRadius;
    var legGeom = new THREE.CylinderGeometry(
                        radius,radius,params.legHeight,64);
    var legMesh = new THREE.Mesh(legGeom,bodyMaterial);
    var shoeGeom = new THREE.SphereGeometry(params.footRadius,32,64);
    var shoeMesh = new THREE.Mesh(shoeGeom,shoeMaterial);
    shoeMesh.scale.set(params.footScaleX,params.footScaleY,params.footScaleZ);
    // shoeMesh.scale.z = params.footScaleZ;
    shoeMesh.position.set(0,-params.legHeight/2,params.footPositionZ);
    legMesh.add(shoeMesh);
    return legMesh;
}

function addLeg(body,side,params,bodyMaterial,shoeMaterial) {
    /* adds a leg to the body
     * @param body {THREE.Mesh} - body mesh
     * @param side - specifies the side of the head to add the leg to
     *               1 for left, -1 for right
     * @param params - collection of dimensions for the leg
     * @param bodyMaterial - color of the leg
     * @param shoeMaterial - color of the shoe */
    var legPositionX = params.headRadius/2;
    var legPositionY = -params.legHeight/2;
    var leg = createLeg(params,bodyMaterial,shoeMaterial);
    leg.position.set(legPositionX*side,legPositionY,0);
    body.add(leg);
}

function makePeppa(params,size,bodyColor,dressColor,shoeColor) {
    /* construct a peppa pig
     * @param params - collection of dimensions
     * @param size - scale of peppa
     * @param bodyColor - color of body
     * @param dressColor - color of dress
     * @param shoeMaterial - color of the shoe 
     * @return {THREE.Object3D} peppa object */
    var bodyMaterial = new THREE.MeshPhongMaterial({color: bodyColor,
                                                    specular: bodyColor,
                                                    shininess: 1});
    var dressMaterial = new THREE.MeshPhongMaterial({color: dressColor,
                                                    specular: THREE.ColorKeywords.white,
                                                    shininess:1});
    var shoeMaterial = new THREE.MeshPhongMaterial({color: shoeColor,
                                                    specular: THREE.ColorKeywords.white,
                                                    shininess:20});
    var eyeMaterial = new THREE.MeshBasicMaterial({color: "white"});
    var mouthMaterial = new THREE.MeshBasicMaterial({color: 0xf54296});
    var dimpleMaterial = new THREE.MeshPhongMaterial({color:0xf28fce,
                                                    specular: 0xf28fce,
                                                    shininess:1});
    var pupilMaterial = new THREE.MeshBasicMaterial({color: "black"});

    var pig = new THREE.Object3D();
    // make head
    var head = makeHead(params,bodyMaterial);
    var noseMesh = makeNose(params,bodyMaterial);
    addDimple(head,params,dimpleMaterial);
    addMouth(head,params,mouthMaterial);
    head.add(noseMesh);
    addEye(head,params,1,eyeMaterial,pupilMaterial);
    addEye(head,params,-1,eyeMaterial,pupilMaterial);
    addEar(head,params,1,bodyMaterial);
    addEar(head,params,-1,bodyMaterial);
    // create the entire body
    var body;
    //this step determines which dress global variable peppe's dress will be assigned to
    if (dressColor == 0xf5574c){
        dress1 = createBody(params,dressMaterial);
        body = dress1;
        console.log("dress1 color detected");
    }
    else if (dressColor == 0x109de8){
        dress2 = createBody(params,dressMaterial);
        body = dress2;
        console.log("dress2 color detected");
    }
    else if (dressColor == 0xed9f2b){
        dress3 = createBody(params,dressMaterial);
        body = dress3;
        console.log("dress3 color detected");
    }
    addArm(body,1,params,bodyMaterial);
    addArm(body,-1,params,bodyMaterial);
    addLeg(body,1,params,bodyMaterial,shoeMaterial);
    addLeg(body,-1,params,bodyMaterial,shoeMaterial);
    // add the completed body to the head
    addBody(head,body,params,dressMaterial);
    pig.add(head);
    return pig;
}



// peppa at the center
var peppaPig = makePeppa(params,1,0xf2a5c9,0xf5574c,"black");
peppaPig.position.set(params.peppa0X, params.peppa0Y, params.peppa0Z);

//peppa on the left
var peppaPig1 = makePeppa(params,1,0xf2a5c9,0x109de8,"black");
peppaPig1.rotation.y = params.peppa1Rotation;
peppaPig1.position.set(params.peppa1X, params.peppa1Y, params.peppa1Z);

//peppa on the right
var peppaPig2 = makePeppa(params,1,0xf2a5c9,0xed9f2b,"black");
peppaPig2.position.set(params.peppa2X, params.peppa2Y, params.peppa2Z);
peppaPig2.rotation.y = params.peppa2Rotation;

//add the figures to the market stand
marketStand.add(peppaPig,peppaPig1,peppaPig2);

marketStand.position.set(0,-40,0);
scene.add(marketStand);


function displayBackground(textures){
    textures[0].wrapS = THREE.MirroredRepeatWrapping;
    textures[0].wrapT = THREE.RepeatWrapping;
    textures[0].repeat.set(1,1);
    textures[0].needsUpdate = true;

    textures[1].wrapS = THREE.MirroredRepeatWrapping;
    textures[1].wrapT = THREE.MirroredRepeatWrapping;
    textures[1].repeat.set(4,4);
    textures[1].needsUpdate = true;

    textures[2].wrapS = THREE.MirroredRepeatWrapping;
    textures[2].wrapT = THREE.RepeatWrapping;
    textures[2].repeat.set(1,1);

    textures[3].wrapS = THREE.MirroredRepeatWrapping;
    textures[3].wrapT = THREE.RepeatWrapping;
    textures[3].repeat.set(1,1);

    textures[4].wrapS = THREE.MirroredRepeatWrapping;
    textures[4].wrapT = THREE.RepeatWrapping;
    textures[4].repeat.set(1,1);

    textures[5].wrapS = THREE.MirroredRepeatWrapping;
    textures[5].wrapT = THREE.RepeatWrapping;
    textures[5].repeat.set(1,1);

    textures[6].wrapS = THREE.MirroredRepeatWrapping;
    textures[6].wrapT = THREE.RepeatWrapping;
    textures[6].repeat.set(1,1);

    textures[7].wrapS = THREE.MirroredRepeatWrapping;
    textures[7].wrapT = THREE.RepeatWrapping;
    textures[7].repeat.set(1,1);

    textures[8].wrapS = THREE.MirroredRepeatWrapping;
    textures[8].wrapT = THREE.RepeatWrapping;
    textures[8].repeat.set(1,1);

    textures[9].wrapS = THREE.MirroredRepeatWrapping;
    textures[9].wrapT = THREE.RepeatWrapping;
    textures[9].repeat.set(1,1);

    textures[10].wrapS = THREE.MirroredRepeatWrapping;
    textures[10].wrapT = THREE.RepeatWrapping;
    textures[10].repeat.set(1,1);

    textures[11].wrapS = THREE.MirroredRepeatWrapping;
    textures[11].wrapT = THREE.RepeatWrapping;
    textures[11].repeat.set(1,1);

    textures[12].wrapS = THREE.MirroredRepeatWrapping;
    textures[12].wrapT = THREE.RepeatWrapping;
    textures[12].repeat.set(1,1);

    // plane of alley in background
    var planeGeom = new THREE.PlaneGeometry(600,400);
    var planeMat = new THREE.MeshBasicMaterial( {color:0xffffff,map:textures[0]} );
    var planeMesh = new THREE.Mesh(planeGeom, planeMat);
    // adding the neon lights to the background
    // create meshes for the neon lights
    var neon1Geom = new THREE.PlaneGeometry(50,50);
    var neon1Mat = new THREE.MeshBasicMaterial({color:0xffffff,map:textures[2]});
    var neon1Mesh = new THREE.Mesh(neon1Geom,neon1Mat);
    neon1Mesh.position.set(50,50,1);

    var neon2Geom = new THREE.PlaneGeometry(80,50);
    var neon2Mat = new THREE.MeshBasicMaterial({color:0xffffff,map:textures[3]});
    var neon2Mesh = new THREE.Mesh(neon2Geom,neon2Mat);
    neon2Mesh.position.set(75,0,1);

    var neon3Geom = new THREE.PlaneGeometry(40,50);
    var neon3Mat = new THREE.MeshBasicMaterial({color:0xffffff,map:textures[4]});
    var neon3Mesh = new THREE.Mesh(neon3Geom,neon3Mat);
    neon3Mesh.position.set(-90,60,1);

    var neon4Geom = new THREE.PlaneGeometry(60,30);
    var neon4Mat = new THREE.MeshBasicMaterial({color:0xffffff,map:textures[5]});
    var neon4Mesh = new THREE.Mesh(neon4Geom,neon4Mat);
    neon4Mesh.position.set(-120,30,1.5);

    var neon5Geom = new THREE.PlaneGeometry(50,50);
    var neon5Mat = new THREE.MeshBasicMaterial({color:0xffffff,map:textures[6]});
    var neon5Mesh = new THREE.Mesh(neon5Geom,neon5Mat);
    neon5Mesh.position.set(130,50,1);

    var neon6Geom = new THREE.PlaneGeometry(70,25);
    var neon6Mat = new THREE.MeshBasicMaterial({color:0xffffff,map:textures[7]});
    var neon6Mesh = new THREE.Mesh(neon6Geom,neon6Mat);
    neon6Mesh.position.set(-150,-10,1);

    planeMesh.add(neon1Mesh,neon2Mesh,neon3Mesh,neon4Mesh,neon5Mesh,neon6Mesh);
    planeMesh.position.set(0,150,-80);

    var groundGeom = new THREE.PlaneGeometry(1000,400);
    var groundMat = new THREE.MeshBasicMaterial({color: 0xffffff,
                                                 map: textures[1]});
    var groundMesh = new THREE.Mesh(groundGeom,groundMat);
    groundMesh.rotation.x = -Math.PI/2;
    groundMesh.position.y = -50;
    scene.add(planeMesh,groundMesh);
}

var nframes = 0;
//runTimer makes peppa dance for 12 frames
function runTimer () {
    if (peppa != null) {
        scene.remove(peppa);
    }
    //change peppa's leg and arm parameters in params
    params.peppaPosX += danceX[nframes];
    params.peppaPosY += danceY[nframes];
    peppa = makePeppa(params,1,0xf2a5c9,params.peppaDressColor,"black");
    peppa.position.set(params.peppaPosX, params.peppaPosY, params.peppaPosZ);
    peppa.rotation.y = params.peppaRotation;
    scene.add(peppa);
    nframes += 1;
    console.log("nframes:",nframes);
    if (nframes > 12) {
        clearInterval(clock);        // stop the timer started with setInterval()
        nframes = 0;
        //this step restores the peppa that has been removed from the scene
        if(params.peppaDressColor == params.peppa0Color){
            peppaPig = makePeppa(params,1,0xf2a5c9,0xf5574c,"black");
            peppaPig.position.set(params.peppa0X, params.peppa0Y, params.peppa0Z);
            marketStand.add(peppaPig);
            console.log("peppa0 RESTORED");
        }
        else if(params.peppaDressColor == params.peppa1Color){
            peppaPig1 = makePeppa(params,1,0xf2a5c9,0x109de8,"black");
            peppaPig1.rotation.y = params.peppa1Rotation;
            peppaPig1.position.set(params.peppa1X, params.peppa1Y, params.peppa1Z);
            marketStand.add(peppaPig1);
            console.log("peppa1 RESTORED");
        }
        else if(params.peppaDressColor == params.peppa2Color){
            peppaPig2 = makePeppa(params,1,0xf2a5c9,0xed9f2b,"black");
            peppaPig2.position.set(params.peppa2X, params.peppa2Y, params.peppa2Z);
            peppaPig2.rotation.y = params.peppa2Rotation;
            marketStand.add(peppaPig2);
            console.log("peppa2 RESTORED");
        }
        render();
    } else {
        render();
    }
}



// ===================
// sound
// ===================
function createSoundBox(textures) {
    /* Creates a box to toggle the music and adds it to the scene. 
     * This box object consists of a sound icon encased in a 
     * multi-colored semi-transparent box, inspired by the 
     * mystery cube from Mario Kart.
     * @param textures - contains the image for the sound icon */

    var soundbox = new THREE.Object3D();

    var soundGeom = new THREE.BoxGeometry(20,20,20);
    addTextureCoords(soundGeom, textures);

    var materials = [
        new THREE.MeshPhongMaterial({ 
            color: 0xffffff, map: textures[13] }), // sound icon
        new THREE.MeshPhongMaterial({ 
            color: 0xFFDDFA, transparent: true, opacity: 0.5 }), // pink
        new THREE.MeshPhongMaterial({ 
            color: 0xFEFFDD, transparent: true, opacity: 0.5 }), // yellow
        new THREE.MeshPhongMaterial({ 
            color: 0xD2F3FD, transparent: true, opacity: 0.5 }), // blue
        new THREE.MeshPhongMaterial({ 
            color: 0xD79EFD, transparent: true, opacity: 0.5 }), // purple
        new THREE.MeshPhongMaterial({ 
            color: 0x00ffff, transparent: true, opacity: 0.5 }), // green
        new THREE.MeshPhongMaterial({ 
            color: 0xFED09C, transparent: true, opacity: 0.5 }) // orange
    ]; 

    // put the sound icon on the front of the inner box        
    soundGeom.faces[8].materialIndex = 0;
    soundGeom.faces[9].materialIndex = 0;
    var soundboxMesh = new THREE.Mesh(soundGeom, materials);
    soundbox.add(soundboxMesh);

    // create a transparent box around the sound icon
    var soundboxTransparentGeom = new THREE.BoxGeometry(25,25,25);
    addTextureCoords(soundboxTransparentGeom, textures);
    // right
    soundboxTransparentGeom.faces[0].materialIndex = 1;
    soundboxTransparentGeom.faces[1].materialIndex = 1;
    
    // left
    soundboxTransparentGeom.faces[2].materialIndex = 2;
    soundboxTransparentGeom.faces[3].materialIndex = 2;

    // top
    soundboxTransparentGeom.faces[4].materialIndex = 3;
    soundboxTransparentGeom.faces[5].materialIndex = 3;

    // bottom
    soundboxTransparentGeom.faces[6].materialIndex = 4;
    soundboxTransparentGeom.faces[7].materialIndex = 4;

    // front
    soundboxTransparentGeom.faces[8].materialIndex = 5;
    soundboxTransparentGeom.faces[9].materialIndex = 5;

    // back
    soundboxTransparentGeom.faces[10].materialIndex = 6;
    soundboxTransparentGeom.faces[11].materialIndex = 6;

    var soundboxTransparent = new THREE.Mesh(soundboxTransparentGeom, materials);
    
    // name the transparent encasing of the soundbox (which is larger) 
    // so it is identifiable with the raycaster
    soundboxTransparent.name = "soundbox";
    soundbox.add(soundboxTransparent);

    soundbox.position.set(200,150,10);
    scene.add(soundbox);
}

var listener = new THREE.AudioListener();
camera.add(listener);

var sound = new THREE.Audio(listener);
var audioLoader = new THREE.AudioLoader();

//===================================
// mouse clicks
//===================================
document.addEventListener('click', onClick, false);

// raycasting is used to determine which objects in the 3D space
// map to the mouse click location
var raycaster = new THREE.Raycaster();
var mouse = new THREE.Vector2();

// global variable assigned to canvas element
var c1 = renderer.domElement;

function onClick (event) {  
    // enables the user to click on one of the figures' dresses 
    // and make it dance
    if (event.target == c1) {
        // use canvas offset to determine mouse coordinates in 
        // canvas coordinate frame
        var rect = event.target.getBoundingClientRect();
        var canvasX = event.clientX - rect.left;
        var canvasY = event.clientY - rect.top;
    } else {
        return;
    }

    // get mouse coordinates in the range from -1 to +1 (canvas is 800 x 500 pixels)
    mouse.x = (canvasX / 800) * 2 - 1;
    mouse.y = -(canvasY / 500) * 2 + 1;

    // setup raycaster using mouse position and camera
    raycaster.setFromCamera(mouse, camera);

    // get array of objects projecting to this mouse position, recursively
    // checking all descendants of each object in the scene
    var intersects = raycaster.intersectObjects(scene.children, true);
    
    if (intersects.length > 0) {
        clickedObject = intersects[0].object;
        //this step determines which peppa has been clicked on
        if (clickedObject == dress1) {
            clickedObject = peppaPig;
            params.peppaPosX = params.peppa0X;
            params.peppaPosY = -10;
            params.peppaPosZ = params.peppa0Z;
            params.peppaDressColor = params.peppa0Color;
            params.peppaRotation = params.peppa0Rotation;
            console.log("clicked on peppaPigMiddle");
            marketStand.remove(peppaPig);
            clock = setInterval(runTimer,500);
        } else if (clickedObject == dress2) {
            clickedObject = peppaPig1;
            params.peppaPosX = params.peppa1X;
            params.peppaPosY = -10;
            params.peppaPosZ = params.peppa1Z;
            params.peppaDressColor = params.peppa1Color;
            params.peppaRotation = params.peppa1Rotation;
            console.log("clicked on peppaPigLeft");
            marketStand.remove(peppaPig1);
            clock = setInterval(runTimer,500);
        } else if (clickedObject == dress3) {
            clickedObject = peppaPig2;
            params.peppaPosX = params.peppa2X;
            params.peppaPosY = -10;
            params.peppaPosZ = params.peppa2Z;
            params.peppaDressColor = params.peppa2Color;
            params.peppaRotation = params.peppa2Rotation;
            console.log("clicked on peppaPigRight");
            marketStand.remove(peppaPig2);
            clock = setInterval(runTimer,500);
        }

        if (clickedObject.name == "soundbox") {
            if (!sound.isPlaying) { 
                audioLoader.load( 'music.m4a', function( buffer ) {
                    sound.setBuffer( buffer );
                    sound.setLoop(true);
                    sound.setVolume(0.5);
                    sound.play();
                });
            } else {
                sound.pause();
            }
        }
        
        renderer.render(scene, camera);
   }
}

// ===================
// textures
// ===================
TW.loadTextures(["images/alley1.jpg", "images/bricks.jpg",
                 "images/neon1.jpg", "images/neon2.jpg", "images/neon3.jpg", 
                 "images/neon4.jpg", "images/neon5.jpeg", "images/neon6.jpg",
                 "images/neon7.jpeg", "images/neon8.jpg", "images/neon9.jpg",
                 "images/neon10.jpg", "images/neon11.jpg", "images/sound.png",
                 "images/market-left.png"], 
                function (textures) {
                    textureGlobal = textures;
                    displayBackground(textures);
                    createSoundBox(textures);
                    render();
                } );

// ===================
// lighting
// ===================
var ambLight = new THREE.AmbientLight(0xffffff);
scene.add(ambLight);

var dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
dirLight.position.set(0, params.poleHeight, 
                        params.tableDepth/2 - params.signDepth / 2);
dirLight.target.position.set(0, 0, -params.tableDepth/16);
scene.add(dirLight);
scene.add(dirLight.target);


</script>
</body>
</html>
